### 面向对象基础

##### 面向对象和面向过程的区别

- 面向过程把解决问题的过程拆分成一个个方法，通过一个个方法的执行解决问题

  相对面向对象：缺乏对数据的封装，缺乏数据和方法（对数据的操作）的分离

- 面向过程会抽象出程序，然后用对象执行方法的方式解决问题

  面向对象开发的程序一般更易维护、易复用、易扩展

##### 类

类定义了一种抽象数据类型

> 抽象数据类型可以理解为：将不同类型的数据的集合组成一个整体用来描述一种新的事物

类不但定义了抽象数据类型的组成(成员变量)，同时还定义可以对该类型实施的操作(成员方法)

>  如：
>
> 超人类
>
> ​	特征（成员变量）：身高超过2米，内裤外穿
>
> ​	能力（成员方法）：能飞，举起一座大楼

**引用类型变量**

```java
Object object = new Object();	//即 object 为引用类型变量
```

​	为了能够对实例化的对象进行访问，需要使用一个特殊的变量---引用

​	引用类型变量可以**存放该类对象的地址信息**，通常称为"指向该类的对象"；当一个引用类型变量

指向该类的对象时，就可以通过这个变量对对象实施访问

​	除8种基本类型之外，用类、接口、数组等声明的变量都称为引用类型变量，简称"引用"

> `int[]`  算不算一种数据类型：不算  				**引用类型不算数据类型**

**引用类型变量的赋值**

​	引用类型变量存储的是对象的地址信息，相同类型的引用类型变量之间也可以相互赋值

​	引用类型变量之间的赋值不会创建新的对象，但可能会使得两个以上的引用指向同一个对象

**对象实体和对象引用**

使用 `new` 创建对象实例 （对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）

一个对象引用可以指向0个或1个对象；一个对象可以有n个引用指向它

**对象的相等与指向它们的引用相等区别**

- 对象的相等一般比较的是内存中存放的内容是否相等
- 引用相等一般比较的是它们指向的内存地址是否相等

##### null 和 NullPointerException

对于引用类型变量，可以对其赋值为null，表示没有指向任何对象

```java
String  str = new  String("hello");
str = null;	//引用 str 中的值为 null ，此时没有指向任何 String 对象，但可以调用String中的方法
System.out.println(str.length);	// 发生 NullPointerException
System.out.println(str);	//输出 null
```

##### 成员变量与局部变量的区别

- **语法形式**：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 `public` 、`private` 、 `static` 等修饰符所修饰，而局部变量不能被访问控制修饰符及 `static` 所修饰；但是，成员变量和局部变量都能被 `final`  所修饰
- **存储方式**：从变量在内存中的存储方式来看，如果成员变量是使用 `static` 修饰的，那么这个成员变量是属于类的，如果没有使用 static 修饰，那么这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在与栈内存
- **生存时间**：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡
- **默认值**：从变量是否有默认值来看，成员变量如果没有被赋值，则会自动以类型的默认值而赋值（一种情况例外：被 `final` 修饰的成员变量也必须显式的赋值），而局部变量则不会赋值

**方法的重载**

在Java语言中，允许多个方法的名称相同，但参数列表不同，称之为方法的重载（overload）

> 方法的签名
>
> ​	方法的签名包含如下两个方面：方法名和参数列表
>
> ​	一个类中，不可以有两个方法的签名完全相同，即一个类中不可以有两个方法的方法名和参数列表都完全一样

1. 一个类中，多个方法的名称相同，但参数列表不同

2. 参数列表不同体现在：参数类型、参数个数不同，参数顺序不同

3. 和返回值，修饰符，final修饰以及抛出的异常都没有关系

**编译时根据签名绑定调用方法**

   编译器在编译时会根据签名来绑定不同的方法，我们可以把重载的方法看成是完成的方法，只不过是恰好方法名相同而已

##### 构造方法

生成类的对象时自动执行，无需调用，用来完成对象的初始化工作

1. 命名与类名相同

2. 构造方法没有返回值，但也不能写void

3. 如果源程序中没有定义，编译器在编译时将为其添加一个无参的空构造函数

4. 当定义了构造方法后，Java编译器将不再添加默认的构造方法

5. 构造方法可以 `overload`（重载），但不能 `override` （重写），重载的构造方法之间可以通过在第一行用 `this() / this( args ... )` 互相调用

   > 使用 new 创建对象的时候后面都要加一个括号，因为要调用无参的构造方法
   >
   > 如果重载了有参的构造方法，记得要把无参的构造方法也写出来（无论是否用到），因为可以使创建对象时不发生问题

**this关键字**

`this` 关键字用在方法体中，用于指向调用该方法的当前对象

**对象的初始化过程**

`Student  s = new  Student();`

1. 加载 `Student.class` 文件进内存
2. 在栈中为 `s` 开辟空间
3. 在堆中为学生对象开辟空间
4. 为学生对象的成员变量赋默认值
5. 为学生对象的成员变量赋显示值
6. 通过构造方法给成员变量赋值
7. 对象构造完毕，把地址赋值给 `s` 变量

##### 对象内存管理

编译好的 Java 程序需要运行在 JVM 中

程序，无论是代码还是数据，都需要存储在内存中。JVM为Java程序提供并管理所需要的内存空间，JVM内存分为"栈"、”堆“、”方法区“三个区域，分别存储不同的数据

<img src=".\note_imgs\内存管理1.png" style="zoom:80%;" />

**堆**：存储使用 new 关键字所创建的对象

当一个对象没有任何引用时，被视为废弃的对象，属于被回收的范围，该对象中的所有成员变量也随之回收

`Cell  cell = new  Cell();`

`cell = null ;`

成员变量的声明周期为：从对象在堆中创建开始到对象从堆中被回收结束

**栈**：存放方法中的局部变量

<img src="E:\github\note_imgs\内存管理2.png" style="zoom:80%;" />

局部变量的声明周期

一个运行的 Java 程序从开始到结束会有多次方法的调用

JVM 会为每一个方法的调用在栈中分配一个对应的空间，这个空间称为该方法的栈帧

一个栈帧对应一个正在调用的方法，栈帧中存储了该方法的参数、局部变量等数据，当某一个方法调用完成后，其对应的栈帧将被清除，局部变量失效

**方法区**：存放类的信息

<img src=".\note_imgs\内存管理3.png" style="zoom:80%;" />

 	当类的信息被加载到方法区时，除了类的类型信息以外，同时类内的方法定义也被加载到方法区

​	类在实例化对象时，多个对象会拥有各自在堆中的空间，但所有实例对象是共用在方法区的一份方法定义的

##### 垃圾回收机制

垃圾回收机制（Garbage  Collection，GC）是JVM自带的一个（守护）线程（自动运行着的程序），用于回收没有任何引用指向的对象

Java程序员不用担心内存管理，因为垃圾收集器会自动进行回收管理

**Java程序的内存泄露问题**

内存泄漏是指，不在使用的内存没有被及时的回收，严重的内存泄露会因为过多的内存占用而导致程序的崩溃

GC线程判断对象是否可以回收的依据是该对象是否有引用指向，因此，当确定该对象不存在使用时，应该及时将其引用设置为 `null`

**`System.gc()` 方法**

GC 的回收对程序员来说是透明的，并不一定一发现有无引用对象，就立刻回收

一般情况下，当我们需要 GC 线程立即回收无用对象时，可以调用 `System.gc()` 方法

`System.gc()` 用于 建议 虚拟机马上调用 GC 线程回收资源，具体的实现策略取决于 JVM
