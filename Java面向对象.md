### 面向对象基础

##### 面向对象和面向过程的区别

- 面向过程把解决问题的过程拆分成一个个方法，通过一个个方法的执行解决问题

  相对面向对象：缺乏对数据的封装，缺乏数据和方法（对数据的操作）的分离

- 面向过程会抽象出程序，然后用对象执行方法的方式解决问题

  面向对象开发的程序一般更易维护、易复用、易扩展

##### 类

类定义了一种抽象数据类型

> 抽象数据类型可以理解为：将不同类型的数据的集合组成一个整体用来描述一种新的事物

类不但定义了抽象数据类型的组成(成员变量)，同时还定义可以对该类型实施的操作(成员方法)

>  如：
>
> 超人类
>
> ​	特征（成员变量）：身高超过2米，内裤外穿
>
> ​	能力（成员方法）：能飞，举起一座大楼

**引用类型变量**

```java
Object object = new Object();	//即 object 为引用类型变量
```

​	为了能够对实例化的对象进行访问，需要使用一个特殊的变量---引用

​	引用类型变量可以**存放该类对象的地址信息**，通常称为"指向该类的对象"；当一个引用类型变量

指向该类的对象时，就可以通过这个变量对对象实施访问

​	除8种基本类型之外，用类、接口、数组等声明的变量都称为引用类型变量，简称"引用"

> `int[]`  算不算一种数据类型：不算  				**引用类型不算数据类型**

**引用类型变量的赋值**

​	引用类型变量存储的是对象的地址信息，相同类型的引用类型变量之间也可以相互赋值

​	引用类型变量之间的赋值不会创建新的对象，但可能会使得两个以上的引用指向同一个对象

**对象实体和对象引用**

使用 `new` 创建对象实例 （对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）

一个对象引用可以指向0个或1个对象；一个对象可以有n个引用指向它

**对象的相等与指向它们的引用相等区别**

- 对象的相等一般比较的是内存中存放的内容是否相等
- 引用相等一般比较的是它们指向的内存地址是否相等

##### null 和 NullPointerException

对于引用类型变量，可以对其赋值为null，表示没有指向任何对象

```java
String  str = new  String("hello");
str = null;	//引用 str 中的值为 null ，此时没有指向任何 String 对象，但可以调用String中的方法
System.out.println(str.length());	// 发生 NullPointerException
System.out.println(str);	//输出 null
```

##### 成员变量与局部变量的区别

- **语法形式**：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 `public` 、`private` 、 `static` 等修饰符所修饰，而局部变量不能被访问控制修饰符及 `static` 所修饰；但是，成员变量和局部变量都能被 `final`  所修饰
- **存储方式**：从变量在内存中的存储方式来看，如果成员变量是使用 `static` 修饰的，那么这个成员变量是属于类的，如果没有使用 static 修饰，那么这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在与栈内存
- **生存时间**：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡
- **默认值**：从变量是否有默认值来看，成员变量如果没有被赋值，则会自动以类型的默认值而赋值（一种情况例外：被 `final` 修饰的成员变量也必须显式的赋值），而局部变量则不会赋值

##### 重载与重写的区别

重载是指在一个类中定义多个方法名相同但参数列表不同的方法，在编译时，根据参数和类型来决定绑定哪个方法（编译期绑定）

重写是指在子类中定义和父类完全相同的方法，在程序运行时，根据对象的类型不同（不是引用类型）而调用不同的版本（运行期绑定）

```java
A a = new A();	//B继承于A，A、B都有一个f方法，此时a.f()调用A类中的f方法
A a2 = new B();	//a2.f()调用B类中的f方法
B b = new B();	//b.f()调用B类中的f方法
```

**方法的重载**

在Java语言中，允许多个方法的名称相同，但参数列表不同，称之为方法的重载（overload）

> 方法的签名
>
> ​	方法的签名包含如下两个方面：方法名和参数列表
>
> ​	一个类中，不可以有两个方法的签名完全相同，即一个类中不可以有两个方法的方法名和参数列表都完全一样

1. 一个类中，多个方法的名称相同，但参数列表不同

2. 参数列表不同体现在：参数类型、参数个数不同，参数顺序不同

3. 和返回值，修饰符，final修饰以及抛出的异常都没有关系

**方法的重写**

- 方法名相同，形参列表相同
- 重写的方法必须具有相同的返回类型。如果返回的是类，重写的方法也可以返回该类的子类（协变返回）
- 子类重写的方法的访问权限必须比父类方法的访问权限更大或相等
- 子类重写的方法抛出的异常必须比父类抛出的异常更小或相等
- `final` 修饰的方法不能重写
- 私有方法不能重写，因为子类不能访问

**编译时根据签名绑定调用方法**

   编译器在编译时会根据签名来绑定不同的方法，我们可以把重载的方法看成是不同的方法，只不过是恰好方法名相同而已

##### 构造方法

生成类的对象时自动执行，无需调用，用来完成对象的初始化工作

1. 命名与类名相同

2. 构造方法没有返回值，但也不能写void

3. 如果源程序中没有定义，编译器在编译时将为其添加一个无参的空构造函数

4. 当定义了构造方法后，Java编译器将不再添加默认的构造方法

5. 构造方法可以 `overload`（重载），但不能 `override` （重写），重载的构造方法之间可以通过在第一行用 `this() / this( args ... )` 互相调用

   > 使用 new 创建对象的时候后面都要加一个括号，因为要调用无参的构造方法
   >
   > 如果重载了有参的构造方法，记得要把无参的构造方法也写出来（无论是否用到），因为可以使创建对象时不发生问题

**this关键字**

`this` 关键字用在方法体中，用于指向调用该方法的当前对象

**对象的初始化过程**

`Student  s = new  Student();`

1. 加载 `Student.class` 文件进内存
2. 在栈中为 `s` 开辟空间
3. 在堆中为学生对象开辟空间
4. 为学生对象的成员变量赋默认值
5. 为学生对象的成员变量赋显示值
6. 通过构造方法给成员变量赋值
7. 对象构造完毕，把地址赋值给 `s` 变量

##### 对象内存管理

编译好的 Java 程序需要运行在 JVM 中

程序，无论是代码还是数据，都需要存储在内存中。JVM为Java程序提供并管理所需要的内存空间，JVM内存分为"栈"、”堆“、”方法区“三个区域，分别存储不同的数据

<img src=".\note_imgs\内存管理1.png" style="zoom: 67%;" />

**堆**：存储使用 new 关键字所创建的对象

当一个对象没有任何引用时，被视为废弃的对象，属于被回收的范围，该对象中的所有成员变量也随之回收

`Cell  cell = new  Cell();`

`cell = null ;`

成员变量的声明周期为：从对象在堆中创建开始到对象从堆中被回收结束

**栈**：存放方法中的局部变量

<img src="E:\github\note_imgs\内存管理2.png" style="zoom: 67%;" />

局部变量的声明周期

一个运行的 Java 程序从开始到结束会有多次方法的调用

JVM 会为每一个方法的调用在栈中分配一个对应的空间，这个空间称为该方法的栈帧

一个栈帧对应一个正在调用的方法，栈帧中存储了该方法的参数、局部变量等数据，当某一个方法调用完成后，其对应的栈帧将被清除，局部变量失效

**方法区**：存放类的信息

<img src=".\note_imgs\内存管理3.png" style="zoom: 67%;" />

 	当类的信息被加载到方法区时，除了类的类型信息以外，同时类内的方法定义也被加载到方法区

​	类在实例化对象时，多个对象会拥有各自在堆中的空间，但所有实例对象是共用在方法区的一份方法定义的

##### 垃圾回收机制

垃圾回收机制（Garbage  Collection，GC）是JVM自带的一个（守护）线程（自动运行着的程序），用于回收没有任何引用指向的对象

Java程序员不用担心内存管理，因为垃圾收集器会自动进行回收管理

**Java程序的内存泄露问题**

内存泄漏是指，不在使用的内存没有被及时的回收，严重的内存泄露会因为过多的内存占用而导致程序的崩溃

GC线程判断对象是否可以回收的依据是该对象是否有引用指向，因此，当确定该对象不存在使用时，应该及时将其引用设置为 `null`

**`System.gc()` 方法**

GC 的回收对程序员来说是透明的，并不一定一发现有无引用对象，就立刻回收

一般情况下，当我们需要 GC 线程立即回收无用对象时，可以调用 `System.gc()` 方法

`System.gc()` 用于 建议 虚拟机马上调用 GC 线程回收资源，具体的实现策略取决于 JVM

##### 继承

通过 `extends` 关键字实现类的继承

子类（Sub  class）可以继承父类（Super  class）的成员变量及成员方法（不能继承父类的构造方法），同时也可以定义自己的成员变量的成员方法；Java语言不支持多继承，一个类只能有一个父类，但一个父类可以有多个子类

子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类无法访问，只是拥有，可以通过调用父类的`public` 、`protected` 修饰的方法访问私有属性

新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间，提高开发效率

**继承中的构造方法的调用**

子类的构造方法中通过使用 super 关键字调用父类的构造方法

如果子类的构造方法中没有调用父类的构造方法，java 编译器会自动的加入对父类无参构造方法的调用（如果此时重载了父类的构造方法，没有无参构造方法，会有编译错误）

通过 `super(args ... )` 调用父类的有参构造方法，该语句必须放在子类构造方法的第一行

可以在子类的成员方法中使用 `super.fun()` 调用父类的方法，可以不写在第一行，不能在成员方法中使用 `super()` 调用父类的构造方法 

##### 多态

表示一个对象具有的多种状态，具体表现为父类的引用指向子类的实例

多态不能调用“只在子类存在但在父类不存在”的方法，如果子类重写了父类的方法，真正执行的是子类重写的方法，这些方法都是实例方法；静态方法可以被继承，但不能被重写

如果子类中含有一个返回类型、方法名、参数列表均与父类相同的静态方法，那么子类只是将父类的静态方法进行了隐藏。此时将父类引用指向子类对象，只会调用父类的静态方法，这不具有多态性

（以下摘自笔记）

一个类型的引用指向不同的对象时有不同的实现

强制转型：

1. 可以通过强制转型将父类型变量转换为子类型变量，前提是该变量指向的对象确实是子类的对象
2. 可以通过强制转换将变量转换为接口类型，前提是该变量指向的对象确实实现了该接口
3. 如果在强制转换过程中引用指向错误，将抛出 `ClassCastException` 

<img src=".\note_imgs\多态转型.png" style="zoom: 67%;" />

 总结：只要实例化的类有父类或实现了接口，那么该实例化的类的引用可以在继承的父类和实现的接口中随意转换

`instanceof` ：测试左边的对象是否是右边的类的实例，返回 boolean 的数据类型

`System.out.println( a instanceof A);`

假如有 C 继承与 B ，B 继承于 A，有一个实例化的对象 x ，只要 x 为 A 、B 、C 其中一个类的实例，那么  `x instanceof A`  、  `x instanceof B `、`x instanceof C` 都为 `true`  

##### 访问控制                                       

`package` 语句

定义类是需要指定类的全称，但如果仅仅将类名作为类的唯一标识，则不可避免的出现命名冲突的问题，这会给组件复用以及团队间的合作造成很大麻烦

java语言中，用包（package）的概念来解决命名冲突的问题，在定义类的时候，除了定义类的名称之外还需要指定一个包，定义包名的语法：package  包名，在一个包中可以包含另一个包

`package com.chumeng.a;`

1. `package` 语句必须写在Java 源文件的最开始
2. 类的全称：一旦使用 `package` 语句指定了包名，类的全称即为 “ 包名.类名 ”
3. 不同的包中可以定义相同的类名

在指定包名时应该按照一定规范

eg：`org.apache.commons.lang.StringUtils`

- `StringUtils` ：类名
- `org.apache.commons.lang` ：多层包名
- `org.apache` ：表示公司或组织的信息（一般为域名的反写）
- `commoms` ：表示项目的名称信息
- `lang` ：表示项目某个模块的名称

`import` 语句

访问 jre 里面的额外类库时，需要写该类的全称，eg：`java.util.Scanner  scanner = new  java.util.Scanner(System.in);`  但这样的书写方式过于繁琐，可以在package 后，类的定义前用 import 语句对类的全称进行声明：`import  java.util.Scanner;` 这样就可以在源文件中直接使用类名来访问

**访问控制修饰符**

|   修饰符    |   本类   | 同一个包中的类 |   子类   |  其他类  |
| :---------: | :------: | :------------: | :------: | :------: |
|  `public`   | 可以访问 |    可以访问    | 可以访问 | 可以访问 |
| `protected` | 可以访问 |    可以访问    | 可以访问 |    no    |
|  `default`  | 可以访问 |    可以访问    |    no    |    no    |
|  `private`  | 可以访问 |       no       |    no    |    no    |

##### static

用`static` 修饰的成员变量不属于对象的数据结构，通过类名来引用 `static` 成员

`static` 成员变量和类的信息一起存储在方法区，而不是堆中，一个类的`static` 成员变量只有“一份”，无论该类创建了多少对象

普通成员方法被调用时会隐式的传递对象的引用（this），`static` 修饰的成员方法在调用时没有隐式的传递对象引用，因此在 `static` 方法中不可以使用 `this` 关键字

静态方法不能使用类中的成员变量，因为静态方法没有指向该变量的引用地址，类中被 `static` 修饰的变量称为”类的变量“，不属于成员变量

`static` 只能调用 `static` 修饰的成员变量和成员方法，`static` 方法的作用在于提供一些“工具方法”和“工厂方法”等

static 块：属于类的代码块，在**类加载期间执行**的代码块，只执行一次，可以用来在软件中加载静态资源

##### final

1. 修饰类
   - `final` 修饰的类不能被继承
   - `final` 类中的成员变量可以根据自己的需要设计为`final`，`final` 类中的成员方法都会被隐式的指定为 `final` 方法
2. 修饰方法
   - `final` 修饰的方法不能被重写
   - 一个类的 `private` 方法，会被隐式的指定为 `final` 方法
3. 修饰成员变量
   - `final` 修饰的成员变量必须赋予初始值，且不能二次赋值
   - 有两种方式初始化：
     1. 声明同时初始化
     2. 在构造函数内初始化
   - 如果修饰的成员变量是基本类型，则表示这个变量的值不能改变
   - 如果修饰的成员变量是一个引用类型，则这个引用的地址的值不能改变，但这个引用所指向的对象里面的内容还是可以改变的
4. 修饰静态类变量
   - `static final` 修饰的类变量如果在编译期间可以有确定值，不会引起类的加载；`static final` 常量在编译期会被替换

```java
public class A {
    public static final int I = 1;
    static {
        System.out.println("hello world");
    }
}
```

- 如果此时有其他类调用 `A.I` ，是不会输入 `hello world` ，没有引起 `A` 类的加载

- `System.out.println(A.I)` 会被替换成 `System.out.println(1)` 

使一个方法不能重写的意义：防止子类在定义新方法时造成的”不经意“重写；使一个类不能被继承的意义：可以保护类不被继承修改，可以控制滥用继承对系统造成的危害

##### abstract

由 abstract 修饰的方法为抽象方法，抽象方法只有方法的定义，没有方法体的实现，用一个分号结尾；一个类中如果包含抽象方法，该类应该用 abstract 关键字声明为抽象类；如果一个类继承了抽象类，必须重写其抽象方法；重写的方法不再是一个抽象方法；子类如果不想重写父类的抽象方法，可以将子类也设置为抽象类

- 包含抽象方法的类一定是抽象类
- 抽象类中不一定包含抽象方法，可以包含普通成员变量和普通成员方法
- 抽象类不可以实例化（如果都是抽象方法那实例化将没有意义） 
- abstract 和 final 关键字不可以同时修饰一个类（因为 final 关键字使得类不可以被继承，而 abstract 类不能被继承将没有意义），也不能修饰同一个方法

抽象类的作用

1. 为其子类提供一个公共的类型
2. 封装子类中重复内容（成员变量和成员方法）
3. 定义抽象方法，子类虽然有不同的实现，但方法的定义是一致的

##### 接口

1. 有些时候，不是事物本身具备的功能，我们就考虑使用接口来扩展
2. 接口的特点：
   - 定义接口用关键字：interface
   - 类实现接口用关键字：implements
     - 格式：`class  类名  implements  接口名  {}`
   - 接口不能实例化
   - 接口的子类：
     - 要么是抽象类
     - 要么重写接口中的所有方法
3. 接口的成员特点：
   - 成员变量：
     - 只能是常量
     - 默认修饰符：`public  static  final`
   - 成员方法：
     - 只能是抽象方法
     - 默认修饰符：`public abstract`
   - 建议自己写接口的时候，把默认修饰符加上
4. 类与接口的关系：
   - 类与类：
     - 继承关系，只能单继承，可以多层继承
   - 类与接口：
     - 实现关系，可以单实现，也可以多实现
     - 可以在继承一个类的同时实现多个接口
   - 接口与接口：
     - 继承关系，可以单继承，也可以多继承

接口和抽象类的共同点和区别

**共同点**

- 都不能被实例化
- 都可以包含抽象方法
- 都可以有默认的实现的方法（Java 8 可以用 default 关键字在接口中定义默认方法）

**区别**

- 接口主要用于对类的行为进行约束，实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系
- 一个类只能继承一个类，但是可以实现多个接口
- 接口中的成员变量只能是 `public  static  final`  类型的，不能被修改且必须具有初始值，而抽象类的成员变量默认为 `default` ，可在子类中被重新定义，也可被重新赋值

接口和抽象类的区别（摘自笔记）

1. 抽象类继承与 `object` ，接口不继承 `object`
2. 抽象类有构造器，接口中没有构造器
3. 抽象类中可以有普通成员变量和常量，接口中只能有常量，而且只能是 `public  static  final`
4. 抽象类中可以有抽象方法，也可以有普通的方法，接口中只能有抽象的方法而且修饰符只能是 `public  abstract`
5. 抽象类中可以有 `final` 的方法，接口中不能有 `final` 的方法
6. 抽象类只能是单继承，但接口可以是多继承
7. 抽象类中可以有静态的方法，并且一定是一个普通的方法，可以继承给子类，接口中不可以

##### 内部类

```java
public interface Print{
    void print();
}
```

```java
public class Outer{
    int i;
    void fun(){
        Inner inner = new Inner();
        System.out.println(i);
    }
    class Inner{
        Inner(){
            i = 1;  // 相当于 Outer.this.i = 1; 
        }
    }
    public static void main(String[] args){
        // 匿名内部类
        Print print = new Print(){
          @override
            void print(){
                System.out.println("hello world");
            }
        };
        print.print();
    }
}
```

内部类 `Inner` 通常只服务于类 `Outer` ，对外部其他类不具备可见性，内部类 `Inner` 可以直接调用类 `Outer` 中的成员属性及方法（包括私有的）

一般情况下，`Inner` 对象会在 Outer 对象中创建（构造方法或其它方法）；`Inner` 对象中调用 `Outer` 的属性或方法时会有一个隐式的引用指向创建它的 Outer 类对象（ `Outer.this` ）

如果在一段程序中需要创建一个类的对象（通常这个类需要实现某个接口或继承某个类），而且创建对象后，这个类的价值也就不存在了，这个类可以不必命名，称之为匿名内部类
